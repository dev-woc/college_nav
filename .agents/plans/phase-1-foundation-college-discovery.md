# Feature: Phase 1 — Foundation + College Discovery Agent

The following plan should be complete, but validate documentation and codebase patterns before starting.
Pay special attention to naming of existing utils, types, and models. Import from the right files.

---

## Feature Description

Complete platform foundation for the college navigation app, replacing the link-in-bio scaffold with a college-nav schema, auth role system, student onboarding flow, College Scorecard integration, and the College Discovery Agent. The Discovery Agent proactively builds a personalized, tiered college list for each student — scored on admission probability, net price fit, and outcome quality — with plain-language explanations generated by Claude.

## User Story

As a first-generation high school student
I want to complete a short onboarding survey about my grades, finances, and interests
So that I immediately receive a personalized, tiered college list with plain-English explanations of why each school fits me — with real net price data, not sticker price

## Problem Statement

The current codebase is a link-in-bio scaffold (profiles, linkItems, clickEvents). The college nav platform needs a completely different data model, new auth roles (student/counselor), a multi-step onboarding flow, an external API integration layer (College Scorecard), and an agentic scoring engine with Claude-powered explanations.

## Solution Statement

1. Replace the schema with college-nav tables (user_profiles, student_profiles, counselor_profiles, colleges cache, college_list_entries, agent_runs)
2. Add role-based auth (student/counselor) using a `role` field in `user_profiles`
3. Build a multi-step student onboarding flow that captures academic + financial profile
4. Create a Scorecard API client with a local DB cache to stay within rate limits
5. Implement the College Discovery Agent: fetch matching colleges, score them on 3 dimensions, classify into tiers, generate Claude explanations, persist to `college_list_entries`
6. Build a student dashboard showing the college list and a skeleton counselor dashboard

## Feature Metadata

**Feature Type**: New Capability
**Estimated Complexity**: High
**Primary Systems Affected**: Database schema, auth middleware, onboarding UI, external API integration, agent layer, student dashboard, counselor dashboard
**Dependencies**: `@anthropic-ai/sdk`, `ai` (Vercel AI SDK), College Scorecard API key

---

## CONTEXT REFERENCES

### Relevant Codebase Files — MUST READ BEFORE IMPLEMENTING

- `src/lib/db/schema.ts` — Current schema to be replaced. Mirror table definition patterns (pgTable, uuid PK, timestamps with timezone, uniqueIndex, index, relations)
- `src/lib/db/index.ts` — DB initialization pattern. Reuse exactly: `neon()` → `drizzle(sql, { schema })`
- `src/app/api/profile/route.ts` — API route pattern: rate limit → auth → validate → query → respond. Mirror this for all new routes
- `src/app/api/links/route.ts` — POST/GET pattern with ownership checks
- `src/app/api/links/[id]/route.ts` — Dynamic route + DELETE pattern with `.returning()`
- `src/app/api/slug/check/route.ts` — GET with query params pattern (no auth required)
- `src/lib/auth/server.ts` — `auth.getSession()` returns `{ data: { user: { id, email, name } } }`
- `src/lib/auth/client.ts` — `authClient` for client-side signup/login calls
- `src/middleware.ts` — Cookie-based route protection. Must extend matcher for new protected routes
- `src/lib/validations.ts` — Zod schema patterns. Mirror `.safeParse()`, `.refine()`, `.or()`, `.enum()` usage
- `src/lib/rate-limit.ts` — `createRateLimiter(maxReq, windowMs)` factory + pre-exported limiters
- `src/hooks/use-profile.ts` — Data fetching hook pattern: `useCallback` → `useEffect`, returns `{ data, isLoading, error, refetch }`
- `src/components/auth/signup-form.tsx` — Multi-field form pattern: local state, `FormErrors` object, sequential async ops, `router.push()` on success
- `src/types/index.ts` — Type pattern: `InferSelectModel<typeof table>`, interface definitions for API responses and component props
- `src/test/setup.ts` — Test setup configuration
- `src/lib/__tests__/validations.test.ts` — Vitest pattern: `describe/it/expect`, `.safeParse().success` assertions

### New Files to Create

```
src/
├── lib/
│   ├── db/
│   │   └── schema.ts               REWRITE — full college-nav schema
│   ├── integrations/
│   │   └── scorecard.ts            NEW — College Scorecard API client with DB cache
│   ├── agents/
│   │   └── discovery/
│   │       ├── index.ts            NEW — Agent runner (orchestrates scoring + explanations + persist)
│   │       ├── scoring.ts          NEW — Admission probability, net price fit, outcome scoring
│   │       └── explanations.ts     NEW — Claude prompt templates for plain-language explanations
│   └── ai/
│       └── client.ts               NEW — Anthropic Claude client singleton
├── app/
│   ├── api/
│   │   ├── onboarding/
│   │   │   └── route.ts            NEW — POST: save student onboarding data
│   │   ├── agents/
│   │   │   └── discovery/
│   │   │       └── route.ts        NEW — POST: trigger Discovery Agent for current user
│   │   ├── colleges/
│   │   │   └── search/
│   │   │       └── route.ts        NEW — GET: search cached colleges
│   │   └── user/
│   │       └── route.ts            NEW — GET: current user profile + role
│   ├── (student)/
│   │   ├── layout.tsx              NEW — Student route group layout (auth guard)
│   │   ├── onboarding/
│   │   │   └── page.tsx            NEW — Multi-step onboarding page
│   │   └── dashboard/
│   │       └── page.tsx            NEW — Student college list dashboard
│   └── (counselor)/
│       ├── layout.tsx              NEW — Counselor route group layout (role guard)
│       └── dashboard/
│           └── page.tsx            NEW — Counselor caseload dashboard (skeleton)
├── components/
│   ├── student/
│   │   ├── onboarding-form.tsx     NEW — Multi-step onboarding form
│   │   ├── college-list.tsx        NEW — College list container with tier sections
│   │   └── college-card.tsx        NEW — Individual college card with scores + explanation
│   └── counselor/
│       └── caseload-table.tsx      NEW — Student list with milestone status
├── hooks/
│   ├── use-student-profile.ts      NEW — Fetch current student's profile + onboarding data
│   └── use-college-list.ts         NEW — Fetch current student's college list entries
└── types/
    └── index.ts                    REWRITE — College-nav types replacing link-in-bio types
```

### Files to Remove (Old Link-in-Bio Scaffold)
```
src/components/editor/            DELETE all
src/components/preview/           DELETE all
src/components/themes/            DELETE all
src/app/(dashboard)/              DELETE all
src/app/api/links/                DELETE all
src/app/api/profile/              DELETE all (replaced by /api/user and /api/onboarding)
```

### Relevant Documentation — READ BEFORE IMPLEMENTING

- [College Scorecard API Docs](https://collegescorecard.ed.gov/data/api-documentation/)
  - Section: Fields reference, net price by income bracket field names
  - Key: net price fields are `latest.cost.net_price.public.by_income_level.110001_plus` etc. — see field naming below
  - Why: Exact field names needed to build the Scorecard client
- [College Scorecard Field Dictionary](https://collegescorecard.ed.gov/data/)
  - Download the data dictionary Excel to cross-reference field names
  - Why: Field names differ by institution type (public vs private net price)
- [Anthropic TypeScript SDK](https://github.com/anthropic/anthropic-sdk-typescript)
  - Section: `client.messages.create()` with streaming
  - Why: Used in explanations.ts for generating plain-language college explanations
- [Vercel AI SDK — streamText](https://sdk.vercel.ai/docs/reference/ai-sdk-core/stream-text)
  - Why: Used to stream Discovery Agent responses to the client
- [Drizzle ORM — PostgreSQL](https://orm.drizzle.team/docs/get-started/neon-new)
  - Section: `pgEnum`, `pgTable`, `relations`, query builder
  - Why: New schema uses enums and more complex relations than the current schema
- [Neon Auth Docs](https://neon.tech/docs/guides/neon-auth)
  - Section: `getSession()` response shape, user object fields
  - Why: Need exact user object shape for role association

---

## PATTERNS TO FOLLOW

### API Route Pattern (from `src/app/api/profile/route.ts`)
```typescript
export async function POST(request: NextRequest) {
  // 1. Rate limit
  const ip = request.headers.get("x-forwarded-for") ?? "anonymous";
  const { success } = apiRateLimiter.check(ip);
  if (!success) return NextResponse.json({ error: "Too many requests" }, { status: 429 });

  // 2. Auth
  const { data } = await auth.getSession();
  if (!data?.user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  // 3. Validate
  const body = await request.json();
  const result = someSchema.safeParse(body);
  if (!result.success) return NextResponse.json({ error: result.error.issues[0]?.message }, { status: 400 });

  // 4. Query
  const [record] = await db.insert(table).values({...}).returning();

  // 5. Respond
  return NextResponse.json({ record }, { status: 201 });
}
```

### Zod Schema Pattern (from `src/lib/validations.ts`)
```typescript
export const mySchema = z.object({
  field: z.string().min(1).max(100),
  enumField: z.enum(["a", "b", "c"]),
  optionalUrl: z.string().url().or(z.literal("")),
}).refine((d) => condition, { message: "Custom message" });
```

### DB Schema Pattern (from `src/lib/db/schema.ts`)
```typescript
export const myTable = pgTable(
  "my_table",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    userId: text("user_id").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => [
    uniqueIndex("idx_my_table_user_id").on(table.userId),
  ]
);
```

### Data Fetching Hook Pattern (from `src/hooks/use-profile.ts`)
```typescript
export function useMyHook(): ReturnType {
  const router = useRouter();
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/endpoint");
      if (!res.ok) {
        if (res.status === 401) { router.push("/login"); return; }
        throw new Error("Failed to fetch");
      }
      const json = await res.json();
      setData(json.data ?? null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
    } finally {
      setIsLoading(false);
    }
  }, [router]);

  useEffect(() => { fetchData(); }, [fetchData]);
  return { data, isLoading, error, refetch: fetchData };
}
```

### College Scorecard Field Names (critical)
```
# Admission
latest.admissions.admission_rate.overall

# Net price by income bracket (public institutions)
latest.cost.net_price.public.by_income_level.0-30000
latest.cost.net_price.public.by_income_level.30001-48000
latest.cost.net_price.public.by_income_level.48001-75000
latest.cost.net_price.public.by_income_level.75001-110000
latest.cost.net_price.public.by_income_level.110001-plus

# Net price by income bracket (private institutions)
latest.cost.net_price.private.by_income_level.0-30000
latest.cost.net_price.private.by_income_level.30001-48000
latest.cost.net_price.private.by_income_level.48001-75000
latest.cost.net_price.private.by_income_level.75001-110000
latest.cost.net_price.private.by_income_level.110001-plus

# Completion / graduation
latest.completion.completion_rate_4yr_150nt   # 4-year schools
latest.completion.completion_rate_less_than_4yr_150nt  # 2-year/community

# Earnings outcomes
latest.earnings.10_yrs_after_entry.median

# Institution info
school.name
school.city
school.state
school.ownership   # 1=public, 2=private nonprofit, 3=for-profit
school.locale      # 11-13=city, 21-23=suburb, 31-33=town, 41-43=rural

# Size
latest.student.size

# IMPORTANT: Field names in API response replace dots with underscores in JSON keys
# e.g., "latest.admissions.admission_rate.overall" →
# response["latest.admissions.admission_rate.overall"]  (dot notation in response key)
```

---

## IMPLEMENTATION PLAN

### Phase 1: Database Schema Redesign

Replace the link-in-bio schema with the college-nav schema. All new tables use the same patterns as existing tables.

**New Schema Tables:**

| Table | Purpose |
|-------|---------|
| `user_profiles` | Universal profile for all users. Has `role` (student/counselor/admin) and `slug`. Replaces old `profiles` |
| `student_profiles` | Student-specific data: GPA, test scores, income bracket, grade level, first-gen flag, state, intended major |
| `counselor_profiles` | Counselor-specific data: school name, district, state |
| `counselor_students` | Junction table: links counselors to their students |
| `colleges` | Local cache of Scorecard data. Refreshed periodically. Avoids repeated API calls |
| `college_list_entries` | A student's personalized list. Stores scores, tier, explanation, saved/applied status |
| `agent_runs` | Log of every agent execution with status, duration, and summary (counselor-visible) |

### Phase 2: Auth Role System

Extend middleware to protect counselor routes. Add role-checking utilities for API routes.

### Phase 3: Student Onboarding

Multi-step form that captures the student's academic profile (grade, GPA, SAT/ACT) and financial profile (income bracket). Saves to `student_profiles`. Redirects to dashboard on completion.

### Phase 4: College Scorecard Integration

A typed API client that fetches college data from the Scorecard API and upserts results into the local `colleges` cache table. Includes a search function for the `/api/colleges/search` endpoint.

### Phase 5: Discovery Agent

The scoring engine and agent runner:
1. Fetch candidate colleges matching student's preferences from local cache + Scorecard
2. Score each on 3 dimensions (admission probability, net price fit, outcome quality)
3. Classify into tiers (Reach/Match/Likely)
4. Generate plain-language explanations via Claude (batched, 1 Claude call per 5 colleges)
5. Persist results to `college_list_entries`

### Phase 6: Student Dashboard

College list UI with tier sections, college cards showing scores and explanations, and an agent status indicator. Triggers agent run on first load if no list exists.

### Phase 7: Counselor Dashboard Skeleton

Caseload table showing students with onboarding status. Role-protected route.

---

## STEP-BY-STEP TASKS

---

### TASK 1: Install New Dependencies

**UPDATE** `package.json` via npm install

- **IMPLEMENT**: Add `@anthropic-ai/sdk` and `ai` (Vercel AI SDK)
- **VALIDATE**: `npm install @anthropic-ai/sdk ai --legacy-peer-deps`
- **GOTCHA**: Use `--legacy-peer-deps` (existing project constraint)

---

### TASK 2: REWRITE `src/lib/db/schema.ts`

**IMPLEMENT** the full college-nav schema, replacing all link-in-bio tables.

```typescript
import { relations } from "drizzle-orm";
import {
  boolean, index, integer, pgTable, pgEnum, real,
  text, timestamp, uniqueIndex, uuid
} from "drizzle-orm/pg-core";

// Enums
export const userRoleEnum = pgEnum("user_role", ["student", "counselor", "admin"]);
export const incomeBracketEnum = pgEnum("income_bracket", [
  "0_30k", "30_48k", "48_75k", "75_110k", "110k_plus"
]);
export const collegeTierEnum = pgEnum("college_tier", ["reach", "match", "likely"]);
export const agentStatusEnum = pgEnum("agent_status", ["pending", "running", "completed", "failed"]);
export const applicationStatusEnum = pgEnum("application_status", [
  "saved", "applied", "accepted", "rejected", "enrolled"
]);

// user_profiles — universal profile for all users
export const userProfiles = pgTable("user_profiles", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: text("user_id").notNull().unique(),   // Neon Auth user.id
  slug: text("slug").notNull().unique(),
  displayName: text("display_name").notNull().default(""),
  email: text("email").notNull().default(""),
  role: userRoleEnum("role").notNull().default("student"),
  onboardingCompleted: boolean("onboarding_completed").notNull().default(false),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
}, (table) => [
  uniqueIndex("idx_user_profiles_user_id").on(table.userId),
  uniqueIndex("idx_user_profiles_slug").on(table.slug),
  index("idx_user_profiles_role").on(table.role),
]);

// student_profiles — academic + financial info for students
export const studentProfiles = pgTable("student_profiles", {
  id: uuid("id").defaultRandom().primaryKey(),
  userProfileId: uuid("user_profile_id").notNull().unique().references(() => userProfiles.id, { onDelete: "cascade" }),
  gradeLevel: integer("grade_level"),          // 9, 10, 11, 12
  gpa: real("gpa"),                            // 0.0 - 4.0
  satScore: integer("sat_score"),              // 400-1600, nullable
  actScore: integer("act_score"),              // 1-36, nullable
  stateOfResidence: text("state_of_residence"), // 2-letter code
  incomeBracket: incomeBracketEnum("income_bracket"),
  isFirstGen: boolean("is_first_gen").notNull().default(false),
  intendedMajor: text("intended_major"),       // free text, e.g. "Computer Science"
  collegeTypePreference: text("college_type_preference"), // "public" | "private" | "either"
  locationPreference: text("location_preference"), // "in_state" | "anywhere" | "regional"
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
}, (table) => [
  index("idx_student_profiles_user_profile_id").on(table.userProfileId),
]);

// counselor_profiles — school/district info for counselors
export const counselorProfiles = pgTable("counselor_profiles", {
  id: uuid("id").defaultRandom().primaryKey(),
  userProfileId: uuid("user_profile_id").notNull().unique().references(() => userProfiles.id, { onDelete: "cascade" }),
  schoolName: text("school_name").notNull().default(""),
  district: text("district").notNull().default(""),
  stateCode: text("state_code").notNull().default(""),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
}, (table) => [
  index("idx_counselor_profiles_user_profile_id").on(table.userProfileId),
]);

// counselor_students — junction: counselor manages student
export const counselorStudents = pgTable("counselor_students", {
  id: uuid("id").defaultRandom().primaryKey(),
  counselorProfileId: uuid("counselor_profile_id").notNull().references(() => counselorProfiles.id, { onDelete: "cascade" }),
  studentProfileId: uuid("student_profile_id").notNull().references(() => studentProfiles.id, { onDelete: "cascade" }),
  connectedAt: timestamp("connected_at", { withTimezone: true }).defaultNow().notNull(),
}, (table) => [
  uniqueIndex("idx_counselor_students_pair").on(table.counselorProfileId, table.studentProfileId),
  index("idx_counselor_students_counselor").on(table.counselorProfileId),
  index("idx_counselor_students_student").on(table.studentProfileId),
]);

// colleges — local cache of Scorecard data
export const colleges = pgTable("colleges", {
  id: uuid("id").defaultRandom().primaryKey(),
  scorecardId: integer("scorecard_id").notNull().unique(),   // Scorecard `id` field
  name: text("name").notNull(),
  city: text("city").notNull().default(""),
  state: text("state").notNull().default(""),
  ownership: integer("ownership"),                           // 1=public, 2=private nonprofit, 3=for-profit
  admissionRate: real("admission_rate"),                     // 0.0-1.0
  netPrice0_30k: integer("net_price_0_30k"),
  netPrice30_48k: integer("net_price_30_48k"),
  netPrice48_75k: integer("net_price_48_75k"),
  netPrice75_110k: integer("net_price_75_110k"),
  netPrice110kPlus: integer("net_price_110k_plus"),
  completionRate: real("completion_rate"),
  medianEarnings10yr: integer("median_earnings_10yr"),
  studentSize: integer("student_size"),
  cachedAt: timestamp("cached_at", { withTimezone: true }).defaultNow().notNull(),
}, (table) => [
  uniqueIndex("idx_colleges_scorecard_id").on(table.scorecardId),
  index("idx_colleges_state").on(table.state),
  index("idx_colleges_ownership").on(table.ownership),
]);

// college_list_entries — a student's personalized college list
export const collegeListEntries = pgTable("college_list_entries", {
  id: uuid("id").defaultRandom().primaryKey(),
  studentProfileId: uuid("student_profile_id").notNull().references(() => studentProfiles.id, { onDelete: "cascade" }),
  collegeId: uuid("college_id").notNull().references(() => colleges.id, { onDelete: "cascade" }),
  tier: collegeTierEnum("tier").notNull(),
  admissionScore: real("admission_score").notNull(),          // 0-100
  netPriceScore: real("net_price_score").notNull(),           // 0-100
  outcomeScore: real("outcome_score").notNull(),              // 0-100
  compositeScore: real("composite_score").notNull(),          // 0-100
  explanation: text("explanation").notNull().default(""),     // Claude-generated
  applicationStatus: applicationStatusEnum("application_status").notNull().default("saved"),
  agentRunId: uuid("agent_run_id"),                           // which run created this
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
}, (table) => [
  index("idx_college_list_student").on(table.studentProfileId),
  uniqueIndex("idx_college_list_student_college").on(table.studentProfileId, table.collegeId),
]);

// agent_runs — log of agent executions
export const agentRuns = pgTable("agent_runs", {
  id: uuid("id").defaultRandom().primaryKey(),
  studentProfileId: uuid("student_profile_id").notNull().references(() => studentProfiles.id, { onDelete: "cascade" }),
  agentType: text("agent_type").notNull(),                    // "discovery" | "financial_aid" | etc.
  status: agentStatusEnum("status").notNull().default("pending"),
  summary: text("summary").notNull().default(""),             // human-readable result
  durationMs: integer("duration_ms"),
  errorMessage: text("error_message"),
  startedAt: timestamp("started_at", { withTimezone: true }).defaultNow().notNull(),
  completedAt: timestamp("completed_at", { withTimezone: true }),
}, (table) => [
  index("idx_agent_runs_student").on(table.studentProfileId),
  index("idx_agent_runs_type").on(table.agentType),
  index("idx_agent_runs_status").on(table.status),
]);

// Relations
export const userProfilesRelations = relations(userProfiles, ({ one }) => ({
  studentProfile: one(studentProfiles, { fields: [userProfiles.id], references: [studentProfiles.userProfileId] }),
  counselorProfile: one(counselorProfiles, { fields: [userProfiles.id], references: [counselorProfiles.userProfileId] }),
}));

export const studentProfilesRelations = relations(studentProfiles, ({ one, many }) => ({
  userProfile: one(userProfiles, { fields: [studentProfiles.userProfileId], references: [userProfiles.id] }),
  collegeListEntries: many(collegeListEntries),
  agentRuns: many(agentRuns),
  counselorStudents: many(counselorStudents),
}));

export const counselorProfilesRelations = relations(counselorProfiles, ({ one, many }) => ({
  userProfile: one(userProfiles, { fields: [counselorProfiles.userProfileId], references: [userProfiles.id] }),
  counselorStudents: many(counselorStudents),
}));

export const counselorStudentsRelations = relations(counselorStudents, ({ one }) => ({
  counselor: one(counselorProfiles, { fields: [counselorStudents.counselorProfileId], references: [counselorProfiles.id] }),
  student: one(studentProfiles, { fields: [counselorStudents.studentProfileId], references: [studentProfiles.id] }),
}));

export const collegesRelations = relations(colleges, ({ many }) => ({
  listEntries: many(collegeListEntries),
}));

export const collegeListEntriesRelations = relations(collegeListEntries, ({ one }) => ({
  student: one(studentProfiles, { fields: [collegeListEntries.studentProfileId], references: [studentProfiles.id] }),
  college: one(colleges, { fields: [collegeListEntries.collegeId], references: [colleges.id] }),
}));

export const agentRunsRelations = relations(agentRuns, ({ one }) => ({
  student: one(studentProfiles, { fields: [agentRuns.studentProfileId], references: [studentProfiles.id] }),
}));
```

- **VALIDATE**: `npm run db:push` (must complete without errors)
- **GOTCHA**: `pgEnum` must be defined BEFORE the tables that use it. Enums are created as Postgres types. If re-running `db:push` on existing schema, Drizzle handles enum creation automatically.
- **GOTCHA**: `real` is for floating-point (scores, GPA). Use `integer` for whole numbers (net price in dollars, earnings).

---

### TASK 3: REWRITE `src/types/index.ts`

**IMPLEMENT** college-nav types, replacing all link-in-bio types.

```typescript
import type { InferSelectModel } from "drizzle-orm";
import type {
  userProfiles, studentProfiles, counselorProfiles,
  colleges, collegeListEntries, agentRuns, counselorStudents
} from "@/lib/db/schema";

export type UserProfile = InferSelectModel<typeof userProfiles>;
export type StudentProfile = InferSelectModel<typeof studentProfiles>;
export type CounselorProfile = InferSelectModel<typeof counselorProfiles>;
export type College = InferSelectModel<typeof colleges>;
export type CollegeListEntry = InferSelectModel<typeof collegeListEntries>;
export type AgentRun = InferSelectModel<typeof agentRuns>;

export type UserRole = "student" | "counselor" | "admin";
export type IncomeBracket = "0_30k" | "30_48k" | "48_75k" | "75_110k" | "110k_plus";
export type CollegeTier = "reach" | "match" | "likely";
export type ApplicationStatus = "saved" | "applied" | "accepted" | "rejected" | "enrolled";

// API response types
export interface UserWithProfile {
  userProfile: UserProfile;
  studentProfile: StudentProfile | null;
  counselorProfile: CounselorProfile | null;
}

export interface CollegeListEntryWithCollege extends CollegeListEntry {
  college: College;
}

export interface TieredCollegeList {
  reach: CollegeListEntryWithCollege[];
  match: CollegeListEntryWithCollege[];
  likely: CollegeListEntryWithCollege[];
  agentRun: AgentRun | null;
}

// Onboarding form state
export interface StudentOnboardingData {
  gradeLevel: number;
  gpa: number;
  satScore: number | null;
  actScore: number | null;
  stateOfResidence: string;
  incomeBracket: IncomeBracket;
  isFirstGen: boolean;
  intendedMajor: string;
  collegeTypePreference: "public" | "private" | "either";
  locationPreference: "in_state" | "anywhere" | "regional";
}

// Scorecard API response shape (fields we care about)
export interface ScorecardCollege {
  id: number;
  "school.name": string;
  "school.city": string;
  "school.state": string;
  "school.ownership": number;
  "latest.student.size": number | null;
  "latest.admissions.admission_rate.overall": number | null;
  "latest.cost.net_price.public.by_income_level.0-30000": number | null;
  "latest.cost.net_price.public.by_income_level.30001-48000": number | null;
  "latest.cost.net_price.public.by_income_level.48001-75000": number | null;
  "latest.cost.net_price.public.by_income_level.75001-110000": number | null;
  "latest.cost.net_price.public.by_income_level.110001-plus": number | null;
  "latest.cost.net_price.private.by_income_level.0-30000": number | null;
  "latest.cost.net_price.private.by_income_level.30001-48000": number | null;
  "latest.cost.net_price.private.by_income_level.48001-75000": number | null;
  "latest.cost.net_price.private.by_income_level.75001-110000": number | null;
  "latest.cost.net_price.private.by_income_level.110001-plus": number | null;
  "latest.completion.completion_rate_4yr_150nt": number | null;
  "latest.completion.completion_rate_less_than_4yr_150nt": number | null;
  "latest.earnings.10_yrs_after_entry.median": number | null;
}

// Agent scoring result (intermediate, not persisted directly)
export interface CollegeScore {
  college: College;
  admissionScore: number;   // 0-100
  netPriceScore: number;    // 0-100
  outcomeScore: number;     // 0-100
  compositeScore: number;   // 0-100
  tier: CollegeTier;
}
```

- **VALIDATE**: `npx tsc --noEmit` (no type errors)

---

### TASK 4: UPDATE `src/lib/validations.ts`

**ADD** new validation schemas for onboarding and agent API. Keep existing schemas until old routes are removed.

```typescript
// Add to existing validations.ts:

export const onboardingSchema = z.object({
  gradeLevel: z.number().int().min(9).max(12),
  gpa: z.number().min(0).max(4.0),
  satScore: z.number().int().min(400).max(1600).nullable().optional(),
  actScore: z.number().int().min(1).max(36).nullable().optional(),
  stateOfResidence: z.string().length(2, "Must be 2-letter state code"),
  incomeBracket: z.enum(["0_30k", "30_48k", "48_75k", "75_110k", "110k_plus"]),
  isFirstGen: z.boolean(),
  intendedMajor: z.string().max(100).default(""),
  collegeTypePreference: z.enum(["public", "private", "either"]).default("either"),
  locationPreference: z.enum(["in_state", "anywhere", "regional"]).default("anywhere"),
});

export const signupWithRoleSchema = z.object({
  slug: slugSchema,
  role: z.enum(["student", "counselor"]).default("student"),
  displayName: z.string().min(1).max(50),
  // counselor-only fields
  schoolName: z.string().max(100).optional(),
  district: z.string().max(100).optional(),
  stateCode: z.string().length(2).optional(),
});
```

- **VALIDATE**: `npm run lint`

---

### TASK 5: CREATE `src/lib/ai/client.ts`

**IMPLEMENT** Anthropic client singleton.

```typescript
import Anthropic from "@anthropic-ai/sdk";

if (!process.env.ANTHROPIC_API_KEY) {
  throw new Error("ANTHROPIC_API_KEY is required");
}

export const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});
```

- **IMPORTS**: `import Anthropic from "@anthropic-ai/sdk"`
- **VALIDATE**: `npx tsc --noEmit`

---

### TASK 6: CREATE `src/lib/integrations/scorecard.ts`

**IMPLEMENT** College Scorecard API client with DB caching.

```typescript
import type { ScorecardCollege } from "@/types";

const SCORECARD_BASE = "https://api.data.gov/ed/collegescorecard/v1/schools";

const FIELDS = [
  "id",
  "school.name",
  "school.city",
  "school.state",
  "school.ownership",
  "latest.student.size",
  "latest.admissions.admission_rate.overall",
  "latest.cost.net_price.public.by_income_level.0-30000",
  "latest.cost.net_price.public.by_income_level.30001-48000",
  "latest.cost.net_price.public.by_income_level.48001-75000",
  "latest.cost.net_price.public.by_income_level.75001-110000",
  "latest.cost.net_price.public.by_income_level.110001-plus",
  "latest.cost.net_price.private.by_income_level.0-30000",
  "latest.cost.net_price.private.by_income_level.30001-48000",
  "latest.cost.net_price.private.by_income_level.48001-75000",
  "latest.cost.net_price.private.by_income_level.75001-110000",
  "latest.cost.net_price.private.by_income_level.110001-plus",
  "latest.completion.completion_rate_4yr_150nt",
  "latest.completion.completion_rate_less_than_4yr_150nt",
  "latest.earnings.10_yrs_after_entry.median",
].join(",");

export interface ScorecardSearchParams {
  state?: string;               // 2-letter code
  ownership?: 1 | 2 | 3;       // 1=public, 2=private, 3=for-profit
  minAdmissionRate?: number;    // 0.0-1.0
  maxAdmissionRate?: number;    // 0.0-1.0
  perPage?: number;             // default 20, max 100
  page?: number;
}

export async function searchScorecard(params: ScorecardSearchParams): Promise<ScorecardCollege[]> {
  const apiKey = process.env.COLLEGE_SCORECARD_API_KEY;
  if (!apiKey) throw new Error("COLLEGE_SCORECARD_API_KEY is required");

  const url = new URL(SCORECARD_BASE);
  url.searchParams.set("api_key", apiKey);
  url.searchParams.set("fields", FIELDS);
  url.searchParams.set("per_page", String(params.perPage ?? 100));
  url.searchParams.set("page", String(params.page ?? 0));

  // Only include degree-granting institutions
  url.searchParams.set("school.degrees_awarded.predominant__range", "2..4");

  if (params.state) url.searchParams.set("school.state", params.state);
  if (params.ownership) url.searchParams.set("school.ownership", String(params.ownership));
  if (params.minAdmissionRate !== undefined) {
    url.searchParams.set("latest.admissions.admission_rate.overall__range", `${params.minAdmissionRate}..1.0`);
  }
  if (params.maxAdmissionRate !== undefined) {
    const current = url.searchParams.get("latest.admissions.admission_rate.overall__range");
    const min = current?.split("..")[0] ?? "0";
    url.searchParams.set("latest.admissions.admission_rate.overall__range", `${min}..${params.maxAdmissionRate}`);
  }

  const res = await fetch(url.toString());
  if (!res.ok) {
    throw new Error(`Scorecard API error: ${res.status} ${await res.text()}`);
  }

  const json = await res.json() as { results: ScorecardCollege[]; metadata: { total: number } };
  return json.results ?? [];
}

// Convert ScorecardCollege to the DB colleges table values shape
export function scorecardToDbValues(sc: ScorecardCollege) {
  const isPublic = sc["school.ownership"] === 1;
  return {
    scorecardId: sc.id,
    name: sc["school.name"] ?? "",
    city: sc["school.city"] ?? "",
    state: sc["school.state"] ?? "",
    ownership: sc["school.ownership"] ?? null,
    admissionRate: sc["latest.admissions.admission_rate.overall"] ?? null,
    netPrice0_30k: isPublic
      ? sc["latest.cost.net_price.public.by_income_level.0-30000"]
      : sc["latest.cost.net_price.private.by_income_level.0-30000"],
    netPrice30_48k: isPublic
      ? sc["latest.cost.net_price.public.by_income_level.30001-48000"]
      : sc["latest.cost.net_price.private.by_income_level.30001-48000"],
    netPrice48_75k: isPublic
      ? sc["latest.cost.net_price.public.by_income_level.48001-75000"]
      : sc["latest.cost.net_price.private.by_income_level.48001-75000"],
    netPrice75_110k: isPublic
      ? sc["latest.cost.net_price.public.by_income_level.75001-110000"]
      : sc["latest.cost.net_price.private.by_income_level.75001-110000"],
    netPrice110kPlus: isPublic
      ? sc["latest.cost.net_price.public.by_income_level.110001-plus"]
      : sc["latest.cost.net_price.private.by_income_level.110001-plus"],
    completionRate: sc["latest.completion.completion_rate_4yr_150nt"]
      ?? sc["latest.completion.completion_rate_less_than_4yr_150nt"]
      ?? null,
    medianEarnings10yr: sc["latest.earnings.10_yrs_after_entry.median"] ?? null,
    studentSize: sc["latest.student.size"] ?? null,
  };
}
```

- **GOTCHA**: Scorecard fields with dots in the name are returned as-is in the JSON response — the key literally contains dots. Access them with bracket notation: `sc["school.name"]`.
- **GOTCHA**: Net price fields differ by institution ownership type. Public (1) uses `net_price.public.*`, private nonprofit (2) and for-profit (3) use `net_price.private.*`.
- **GOTCHA**: Some colleges have null values for many fields. Always use `?? null` fallbacks.
- **VALIDATE**: `npx tsc --noEmit`

---

### TASK 7: CREATE `src/lib/agents/discovery/scoring.ts`

**IMPLEMENT** the 3-dimension scoring engine. Pure functions, no I/O.

```typescript
import type { College, StudentProfile, IncomeBracket, CollegeScore, CollegeTier } from "@/types";

// Get net price for a student's income bracket from a cached college
function getNetPrice(college: College, bracket: IncomeBracket): number | null {
  const map: Record<IncomeBracket, number | null> = {
    "0_30k": college.netPrice0_30k,
    "30_48k": college.netPrice30_48k,
    "48_75k": college.netPrice48_75k,
    "75_110k": college.netPrice75_110k,
    "110k_plus": college.netPrice110kPlus,
  };
  return map[bracket];
}

// Get approximate family income midpoint for a bracket (for affordability ratio)
function getBracketMidpoint(bracket: IncomeBracket): number {
  const midpoints: Record<IncomeBracket, number> = {
    "0_30k": 20000,
    "30_48k": 39000,
    "48_75k": 61000,
    "75_110k": 92000,
    "110k_plus": 140000,
  };
  return midpoints[bracket];
}

// Score 0-100: higher admission rate = higher score (simpler = more likely)
export function scoreAdmission(college: College): number {
  if (college.admissionRate === null) return 50; // unknown = neutral
  return Math.round(college.admissionRate * 100);
}

// Score 0-100: lower net price relative to family income = higher score
export function scoreNetPrice(college: College, bracket: IncomeBracket): number {
  const netPrice = getNetPrice(college, bracket);
  if (netPrice === null) return 40; // unknown = slightly below neutral
  const familyIncome = getBracketMidpoint(bracket);
  // Affordable = net price < 25% of income (score 100)
  // Unaffordable = net price > 75% of income (score 0)
  const ratio = netPrice / familyIncome;
  const score = Math.max(0, Math.min(100, Math.round((1 - (ratio - 0.25) / 0.5) * 100)));
  return score;
}

// Score 0-100: based on completion rate and earnings
export function scoreOutcome(college: College): number {
  const NATIONAL_MEDIAN_EARNINGS = 45000; // approximate national median for college grads
  const completionScore = college.completionRate !== null
    ? Math.round(college.completionRate * 100)
    : 50;
  const earningsScore = college.medianEarnings10yr !== null
    ? Math.min(100, Math.round((college.medianEarnings10yr / NATIONAL_MEDIAN_EARNINGS) * 50))
    : 50;
  return Math.round(completionScore * 0.4 + earningsScore * 0.6);
}

// Composite weighted score: 30% admission + 40% net price + 30% outcome
export function compositeScore(admission: number, netPrice: number, outcome: number): number {
  return Math.round(admission * 0.30 + netPrice * 0.40 + outcome * 0.30);
}

// Classify tier based on admission score (proxy for admission probability)
export function classifyTier(admissionScore: number): CollegeTier {
  if (admissionScore >= 70) return "likely";
  if (admissionScore >= 35) return "match";
  return "reach";
}

// Score a single college for a student
export function scoreCollegeForStudent(college: College, student: StudentProfile): CollegeScore {
  if (!student.incomeBracket) {
    throw new Error("Student must have incomeBracket set before scoring");
  }
  const admission = scoreAdmission(college);
  const netPrice = scoreNetPrice(college, student.incomeBracket);
  const outcome = scoreOutcome(college);
  const composite = compositeScore(admission, netPrice, outcome);
  const tier = classifyTier(admission);
  return { college, admissionScore: admission, netPriceScore: netPrice, outcomeScore: outcome, compositeScore: composite, tier };
}
```

- **VALIDATE**: `npm run test:run -- src/lib/agents/discovery/scoring`

---

### TASK 8: CREATE `src/lib/agents/discovery/explanations.ts`

**IMPLEMENT** Claude prompt builder for plain-language college explanations.

```typescript
import { anthropic } from "@/lib/ai/client";
import type { CollegeScore, StudentProfile, IncomeBracket } from "@/types";

function formatNetPrice(score: CollegeScore, bracket: IncomeBracket): string {
  const map: Record<IncomeBracket, number | null> = {
    "0_30k": score.college.netPrice0_30k,
    "30_48k": score.college.netPrice30_48k,
    "48_75k": score.college.netPrice48_75k,
    "75_110k": score.college.netPrice75_110k,
    "110k_plus": score.college.netPrice110kPlus,
  };
  const price = map[bracket];
  return price ? `$${price.toLocaleString()}/year` : "net price data unavailable";
}

// Generate explanations for a batch of colleges in one Claude call
export async function generateExplanations(
  scores: CollegeScore[],
  student: StudentProfile,
): Promise<Map<number, string>> {
  const bracket = student.incomeBracket ?? "48_75k";

  const collegeDescriptions = scores.map((s, i) => {
    const admissionPct = s.admissionScore;
    const np = formatNetPrice(s, bracket);
    const completion = s.college.completionRate
      ? `${Math.round(s.college.completionRate * 100)}% graduation rate`
      : "graduation rate unknown";
    const earnings = s.college.medianEarnings10yr
      ? `median earnings $${s.college.medianEarnings10yr.toLocaleString()} 10 years after enrollment`
      : "earnings data unavailable";
    return `${i + 1}. ${s.college.name} (${s.college.city}, ${s.college.state}): ${admissionPct}% acceptance rate, net price ${np} for your income bracket, ${completion}, ${earnings}. Tier: ${s.tier}`;
  }).join("\n");

  const isFirstGen = student.isFirstGen ? "This student is first-generation (no parent with a 4-year degree)." : "";
  const major = student.intendedMajor ? `Intended major: ${student.intendedMajor}.` : "";

  const prompt = `You are a friendly college counselor writing personalized explanations for a high school student's college list.

Student profile: Grade ${student.gradeLevel}, GPA ${student.gpa}, state ${student.stateOfResidence}. ${isFirstGen} ${major}

Here are the colleges on their list with data:
${collegeDescriptions}

Write a 2-3 sentence plain-English explanation for EACH college, numbered to match. Explain:
- Why it appears on their list (admission likelihood, affordability, outcomes)
- The most compelling reason to consider it
- Any important caveat (if acceptance rate is very low, if net price data is missing, etc.)

Use plain language. Never use jargon without explaining it. Address the student directly as "you." Keep each explanation under 60 words.

Format exactly as:
1. [explanation for college 1]
2. [explanation for college 2]
...`;

  const message = await anthropic.messages.create({
    model: "claude-sonnet-4-6",
    max_tokens: 2000,
    messages: [{ role: "user", content: prompt }],
  });

  const text = message.content[0].type === "text" ? message.content[0].text : "";

  // Parse numbered list back into map keyed by index
  const result = new Map<number, string>();
  const lines = text.split("\n").filter(l => /^\d+\./.test(l.trim()));
  lines.forEach((line) => {
    const match = line.match(/^(\d+)\.\s+(.+)/);
    if (match) {
      result.set(parseInt(match[1]) - 1, match[2].trim()); // 0-indexed
    }
  });

  // Fallback for any missing explanations
  scores.forEach((_, i) => {
    if (!result.has(i)) {
      result.set(i, `${scores[i].college.name} is on your list as a ${scores[i].tier} school based on its admission rate and cost data.`);
    }
  });

  return result;
}
```

- **GOTCHA**: Claude model ID must be `"claude-sonnet-4-6"` (the model specified in the environment)
- **GOTCHA**: Process explanations in batches of 10 max per Claude call to keep prompts manageable
- **VALIDATE**: `npx tsc --noEmit`

---

### TASK 9: CREATE `src/lib/agents/discovery/index.ts`

**IMPLEMENT** the Discovery Agent runner that orchestrates the full flow.

```typescript
import { db } from "@/lib/db";
import { colleges, collegeListEntries, agentRuns, studentProfiles } from "@/lib/db/schema";
import { eq, inArray } from "drizzle-orm";
import { searchScorecard, scorecardToDbValues } from "@/lib/integrations/scorecard";
import { scoreCollegeForStudent } from "./scoring";
import { generateExplanations } from "./explanations";
import type { StudentProfile, College } from "@/types";

const COLLEGES_PER_TIER = 5;      // aim for 5 reach, 5 match, 5 likely
const EXPLANATION_BATCH_SIZE = 10; // max colleges per Claude call

export async function runDiscoveryAgent(studentProfileId: string): Promise<string> {
  const startedAt = new Date();

  // Create agent run record
  const [run] = await db.insert(agentRuns).values({
    studentProfileId,
    agentType: "discovery",
    status: "running",
    startedAt,
  }).returning();

  try {
    // 1. Fetch student profile
    const student = await db.query.studentProfiles.findFirst({
      where: eq(studentProfiles.id, studentProfileId),
    });
    if (!student) throw new Error("Student profile not found");

    // 2. Fetch or populate colleges from Scorecard into local cache
    const cachedColleges = await fetchOrPopulateColleges(student);

    // 3. Score all candidates
    const scored = cachedColleges
      .map(c => scoreCollegeForStudent(c, student))
      .sort((a, b) => b.compositeScore - a.compositeScore);

    // 4. Select top colleges per tier
    const selected = [
      ...scored.filter(s => s.tier === "reach").slice(0, COLLEGES_PER_TIER),
      ...scored.filter(s => s.tier === "match").slice(0, COLLEGES_PER_TIER),
      ...scored.filter(s => s.tier === "likely").slice(0, COLLEGES_PER_TIER),
    ];

    // 5. Generate explanations in batches
    const explanationMap = new Map<number, string>();
    for (let i = 0; i < selected.length; i += EXPLANATION_BATCH_SIZE) {
      const batch = selected.slice(i, i + EXPLANATION_BATCH_SIZE);
      const batchExplanations = await generateExplanations(batch, student);
      batchExplanations.forEach((explanation, batchIdx) => {
        explanationMap.set(i + batchIdx, explanation);
      });
    }

    // 6. Delete existing list entries for this student (fresh run)
    await db.delete(collegeListEntries).where(eq(collegeListEntries.studentProfileId, studentProfileId));

    // 7. Insert new entries
    const entries = selected.map((s, i) => ({
      studentProfileId,
      collegeId: s.college.id,
      tier: s.tier,
      admissionScore: s.admissionScore,
      netPriceScore: s.netPriceScore,
      outcomeScore: s.outcomeScore,
      compositeScore: s.compositeScore,
      explanation: explanationMap.get(i) ?? "",
      agentRunId: run.id,
    }));
    await db.insert(collegeListEntries).values(entries);

    // 8. Mark agent run as completed
    const summary = `Found ${selected.length} colleges (${selected.filter(s => s.tier === "reach").length} reach, ${selected.filter(s => s.tier === "match").length} match, ${selected.filter(s => s.tier === "likely").length} likely)`;
    await db.update(agentRuns).set({
      status: "completed",
      summary,
      durationMs: Date.now() - startedAt.getTime(),
      completedAt: new Date(),
    }).where(eq(agentRuns.id, run.id));

    return summary;
  } catch (error) {
    await db.update(agentRuns).set({
      status: "failed",
      errorMessage: error instanceof Error ? error.message : "Unknown error",
      durationMs: Date.now() - startedAt.getTime(),
      completedAt: new Date(),
    }).where(eq(agentRuns.id, run.id));
    throw error;
  }
}

// Fetch colleges from local cache; populate from Scorecard if cache is thin
async function fetchOrPopulateColleges(student: StudentProfile): Promise<College[]> {
  // Build search params based on student preferences
  const searchParams = {
    state: student.locationPreference === "in_state" ? (student.stateOfResidence ?? undefined) : undefined,
    ownership: student.collegeTypePreference === "public" ? (1 as const)
      : student.collegeTypePreference === "private" ? (2 as const)
      : undefined,
    perPage: 100 as const,
  };

  // Check if we have enough cached data (>= 50 colleges matching params)
  const cached = await db.query.colleges.findMany({
    where: searchParams.state ? eq(colleges.state, searchParams.state) : undefined,
  });

  if (cached.length >= 50) return cached;

  // Populate cache from Scorecard
  const scorecardResults = await searchScorecard(searchParams);
  if (scorecardResults.length > 0) {
    await db.insert(colleges)
      .values(scorecardResults.map(scorecardToDbValues))
      .onConflictDoUpdate({
        target: colleges.scorecardId,
        set: {
          admissionRate: (c: typeof colleges.$inferInsert) => c.admissionRate,
          netPrice0_30k: (c: typeof colleges.$inferInsert) => c.netPrice0_30k,
          // ... update all fields on conflict
          cachedAt: new Date(),
        },
      });
  }

  // Return freshly populated data
  return db.query.colleges.findMany({
    where: searchParams.state ? eq(colleges.state, searchParams.state) : undefined,
  });
}
```

- **GOTCHA**: `onConflictDoUpdate` requires the conflict target to match a unique index. `colleges.scorecardId` has a unique index (`idx_colleges_scorecard_id`).
- **GOTCHA**: The agent deletes and re-inserts the list on each run. This is simpler than a diff-and-update for MVP.
- **GOTCHA**: Claude API calls are the slowest part. Keep batches at 10 colleges per call.
- **VALIDATE**: `npx tsc --noEmit`

---

### TASK 10: CREATE API Routes

#### `src/app/api/user/route.ts` — GET current user profile
```typescript
// Returns: { userProfile, studentProfile | null, counselorProfile | null }
// Mirror: src/app/api/profile/route.ts pattern exactly
// Auth required, no rate limit needed (low frequency)
```

#### `src/app/api/onboarding/route.ts` — POST student onboarding data
```typescript
// Validates with onboardingSchema
// Creates/updates student_profiles record
// Sets userProfile.onboardingCompleted = true
// Returns: { studentProfile }
// Status 201 on create, 200 on update
```

#### `src/app/api/agents/discovery/route.ts` — POST trigger Discovery Agent
```typescript
// Auth required
// Checks student has completed onboarding (400 if not)
// Calls runDiscoveryAgent(studentProfileId)
// Returns: { summary, agentRunId }
// Status 202 (accepted) — agent runs synchronously for MVP but use 202 to indicate async intent
```

#### `src/app/api/colleges/search/route.ts` — GET search college cache
```typescript
// Query params: ?q=name&state=AZ&ownership=1&page=0&perPage=20
// No auth required
// Queries local colleges table
// Returns: { results: College[], total }
```

#### `src/app/api/student/college-list/route.ts` — GET current student's list
```typescript
// Auth required
// Queries college_list_entries with college join for current student
// Returns: { reach: [...], match: [...], likely: [...], agentRun: AgentRun | null }
```

- **PATTERN**: Mirror `src/app/api/profile/route.ts` exactly for rate limiting, auth, validation order
- **VALIDATE**: Test each route with `curl` or Postman after implementing

---

### TASK 11: UPDATE `src/middleware.ts`

**ADD** counselor route protection and expand matcher.

```typescript
const COUNSELOR_ROUTES = ["/counselor", "/counselor/"];

export async function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname;
  const allCookies = request.cookies.getAll();
  const sessionCookie = allCookies.find(c => c.name.includes("neon-auth.session_token"));

  if (!sessionCookie?.value) {
    const loginUrl = new URL("/login", request.url);
    loginUrl.searchParams.set("callbackUrl", path);
    return NextResponse.redirect(loginUrl);
  }

  // Note: deep role checking (counselor-only routes) is handled in API routes + layouts
  // Middleware only checks session cookie presence for performance
  return NextResponse.next();
}

export const config = {
  matcher: [
    "/student/:path*",
    "/counselor/:path*",
    "/onboarding/:path*",
  ],
};
```

- **VALIDATE**: `npm run build` (no middleware compile errors)

---

### TASK 12: CREATE Onboarding UI

#### `src/components/student/onboarding-form.tsx`

Multi-step form with 3 steps:
1. **Academic Profile**: grade level (select 9-12), GPA (number input 0.0-4.0), SAT (optional), ACT (optional)
2. **Financial Profile**: income bracket (select with plain-language labels e.g. "Under $30,000/year"), first-gen flag (checkbox with explanation: "Neither parent has a 4-year college degree")
3. **Preferences**: intended major (text input), college type (radio: public/private/either), location (radio: in-state/regional/anywhere)

**Pattern**: Mirror `src/components/auth/signup-form.tsx`:
- Local state per field, `FormErrors` object
- Step index state (`currentStep: 0 | 1 | 2`)
- "Next" validates current step before advancing
- "Submit" on final step calls `fetch("/api/onboarding", { method: "POST", body: JSON.stringify(data) })`
- Show loading state on submit
- `router.push("/student/dashboard")` on success

#### `src/app/(student)/onboarding/page.tsx`
```typescript
// Simple page wrapping OnboardingForm
// Title: "Tell us about yourself"
// Subtitle: "This takes 2 minutes and helps us find the right colleges for you"
```

---

### TASK 13: CREATE Student Dashboard UI

#### `src/components/student/college-card.tsx`

Props: `entry: CollegeListEntryWithCollege`

Display:
- College name (bold), city + state
- Tier badge (color-coded: red=reach, yellow=match, green=likely)
- Three score bars: Admission Fit, Affordability, Outcomes (each 0-100, shown as colored progress bars)
- Net price for student's bracket (shown prominently)
- Claude explanation (body text, italicized)
- "View more" expand for acceptance rate + earnings data

#### `src/components/student/college-list.tsx`

Props: `list: TieredCollegeList`

Display:
- Three sections: "Reach", "Match", "Likely" (collapsible)
- Each section shows count badge + list of `CollegeCard` components
- Empty state if a tier has 0 colleges
- "Refresh list" button that calls `POST /api/agents/discovery`

#### `src/app/(student)/dashboard/page.tsx`

```typescript
// Uses useCollegeList hook
// On first load with no list: shows "Building your college list..." + triggers agent
// Shows college-list component when data available
// Shows agent status (last run time, summary)
```

---

### TASK 14: CREATE Counselor Dashboard Skeleton

#### `src/components/counselor/caseload-table.tsx`

Columns: Student Name | Grade | FAFSA Status | College List | Onboarding | Last Agent Run

Data: fetched from `/api/counselor/caseload` (GET — returns students connected to counselor)

For MVP, students connect to a counselor via a shareable counselor code (counselor's slug). Implement `/api/counselor/caseload` route returning list of connected students with milestone status (onboarding complete, college list built Y/N).

#### `src/app/(counselor)/dashboard/page.tsx`

```typescript
// Role check: if userProfile.role !== "counselor", redirect to /student/dashboard
// Shows caseload table
// Header: "Your Students" + count
// Empty state if no connected students
```

---

### TASK 15: UPDATE `src/app/page.tsx` (Landing Page)

**UPDATE** the root page to be a landing page for the college nav platform:
- Hero: "Your personal college counselor, available 24/7"
- Two CTAs: "Get started (free)" → `/signup` and "I'm a counselor" → `/signup?role=counselor`
- Brief feature highlights: college list, financial aid, scholarships
- Remove all link-in-bio references

---

### TASK 16: UPDATE Auth Signup Flow

**UPDATE** `src/app/(auth)/signup/page.tsx` and `src/components/auth/signup-form.tsx`:
- Add role selection (student vs counselor) — hidden if `?role=counselor` in URL
- Add counselor-specific fields when role=counselor: school name, district, state
- API call: `POST /api/user` with role, slug, displayName (replaces old `POST /api/profile`)
- On success: redirect to `/student/onboarding` for students, `/counselor/dashboard` for counselors

---

### TASK 17: UPDATE `.env.example`

**ADD** new required environment variables:
```bash
# Existing
DATABASE_URL=
AUTH_SECRET=

# New for Phase 1
ANTHROPIC_API_KEY=
COLLEGE_SCORECARD_API_KEY=
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

---

### TASK 18: DELETE Old Scaffold Files

**REMOVE** link-in-bio files that are no longer needed:
```
src/components/editor/           (all files)
src/components/preview/          (all files)
src/components/themes/           (all files)
src/app/(dashboard)/             (all files)
src/app/api/links/               (all files)
src/app/api/profile/             (old profile routes)
src/app/[slug]/                  (public profile page, if it exists)
```

- **VALIDATE**: `npm run build` (must compile clean with no missing imports)

---

## TESTING STRATEGY

### Unit Tests

Location: `src/lib/agents/discovery/__tests__/scoring.test.ts`

```typescript
import { describe, it, expect } from "vitest";
import { scoreAdmission, scoreNetPrice, scoreOutcome, compositeScore, classifyTier } from "../scoring";
import type { College } from "@/types";

const mockCollege: College = {
  id: "uuid-1",
  scorecardId: 123,
  name: "Test University",
  city: "Phoenix", state: "AZ",
  ownership: 1,
  admissionRate: 0.60,
  netPrice0_30k: 8000,
  netPrice30_48k: 12000,
  netPrice48_75k: 18000,
  netPrice75_110k: 24000,
  netPrice110kPlus: 35000,
  completionRate: 0.62,
  medianEarnings10yr: 48000,
  studentSize: 15000,
  cachedAt: new Date(),
};

describe("scoreAdmission", () => {
  it("returns 60 for 60% admission rate", () => {
    expect(scoreAdmission(mockCollege)).toBe(60);
  });
  it("returns 50 for null admission rate", () => {
    expect(scoreAdmission({ ...mockCollege, admissionRate: null })).toBe(50);
  });
});

describe("scoreNetPrice", () => {
  it("gives high score for low net price relative to income", () => {
    const score = scoreNetPrice(mockCollege, "0_30k"); // $8000 vs $20k income
    expect(score).toBeGreaterThan(70);
  });
  it("gives lower score for high net price relative to income", () => {
    const score = scoreNetPrice(mockCollege, "0_30k");
    const score2 = scoreNetPrice(mockCollege, "110k_plus"); // same price, higher income bracket
    expect(score2).toBeLessThan(score); // wrong direction, actually higher income = lower score for same price
    // Actually: higher income bracket means the same net price is more affordable → higher score
    // Adjust test accordingly
  });
});

describe("classifyTier", () => {
  it("returns 'likely' for score >= 70", () => expect(classifyTier(75)).toBe("likely"));
  it("returns 'match' for score 35-69", () => expect(classifyTier(50)).toBe("match"));
  it("returns 'reach' for score < 35", () => expect(classifyTier(20)).toBe("reach"));
});
```

### Integration Tests

- E2E: Student signup → onboarding → discovery agent runs → college list displays
- Use `tests/e2e/` directory with existing `agent-browser` pattern

### Edge Cases

- Student with no income bracket set (should use default, not crash)
- College with all null net price fields (scoreNetPrice returns 40 neutral)
- College with null admission rate (returns 50 neutral, classified as "match")
- Discovery agent with zero Scorecard results (should return error, not crash)
- Claude API timeout (agent run marked "failed", error message stored)

---

## VALIDATION COMMANDS

### Level 1: Syntax & Style
```bash
npm run lint
```

### Level 2: Type Checking
```bash
npx tsc --noEmit
```

### Level 3: Unit Tests
```bash
npm run test:run
```

### Level 4: Database Schema
```bash
npm run db:push
# Verify: all tables created, no migration errors
```

### Level 5: Build
```bash
npm run build
# Must complete with 0 errors, 0 TypeScript errors
```

### Level 6: Manual Validation
```bash
# Start dev server
npm run dev

# Test signup as student
# 1. Go to http://localhost:3000/signup
# 2. Sign up with email/password
# 3. Should redirect to /student/onboarding

# Test onboarding
# 4. Complete 3-step form (use: grade 11, GPA 3.5, income bracket $30-48k, first-gen, Computer Science)
# 5. Should redirect to /student/dashboard

# Test Discovery Agent
# 6. Dashboard should show "Building your college list..."
# 7. Wait for agent to complete (10-30 seconds first time)
# 8. List should show 3 tiers with colleges and explanations

# Test Scorecard integration (requires COLLEGE_SCORECARD_API_KEY)
curl "https://api.data.gov/ed/collegescorecard/v1/schools?api_key=YOUR_KEY&school.state=AZ&fields=id,school.name,latest.admissions.admission_rate.overall&per_page=3"
# Should return JSON with 3 Arizona schools
```

---

## ACCEPTANCE CRITERIA

- [ ] `npm run build` completes with zero errors
- [ ] `npx tsc --noEmit` reports zero type errors
- [ ] `npm run lint` reports zero errors
- [ ] `npm run test:run` all tests pass
- [ ] `npm run db:push` creates all 7 new tables without errors
- [ ] Student can sign up, complete onboarding, and reach dashboard in one flow
- [ ] Discovery Agent generates a college list with at least 3 colleges across 2+ tiers
- [ ] Each college card shows: name, tier, net price, explanation, scores
- [ ] Counselor signup flow creates counselor role profile
- [ ] Counselor dashboard is role-protected (students are redirected)
- [ ] No link-in-bio UI or routes are reachable
- [ ] All API routes return `{ error: "Unauthorized" }` (401) without a session cookie
- [ ] Rate limiting blocks >30 requests/minute per IP on agent and onboarding routes

---

## COMPLETION CHECKLIST

- [ ] Task 1: Dependencies installed (`@anthropic-ai/sdk`, `ai`)
- [ ] Task 2: Schema rewritten, `db:push` successful
- [ ] Task 3: Types rewritten, `tsc --noEmit` passes
- [ ] Task 4: Validation schemas added
- [ ] Task 5: AI client created
- [ ] Task 6: Scorecard integration client created
- [ ] Task 7: Scoring engine created + unit tests passing
- [ ] Task 8: Explanation generator created
- [ ] Task 9: Agent runner created
- [ ] Task 10: All 5 new API routes created
- [ ] Task 11: Middleware updated
- [ ] Task 12: Onboarding form + page created
- [ ] Task 13: College card, list, and dashboard created
- [ ] Task 14: Counselor dashboard skeleton created
- [ ] Task 15: Landing page updated
- [ ] Task 16: Signup flow updated for roles
- [ ] Task 17: `.env.example` updated
- [ ] Task 18: Old scaffold files deleted
- [ ] `npm run build` passes clean
- [ ] Full manual validation flow completed

---

## NOTES

### Design Decisions

1. **Synchronous agent for MVP**: The Discovery Agent runs synchronously in the API route (user waits for it). Phase 2 will add a proper async queue (BullMQ or Vercel Cron). For MVP, acceptable latency is 10-30 seconds; show a loading state.

2. **Local college cache**: Rather than calling Scorecard on every discovery run, we cache colleges in the `colleges` table. This avoids the 1,000 req/hr rate limit and makes subsequent agent runs near-instant. Cache is considered fresh for 30 days (not implemented in MVP — add `cachedAt` check in Phase 2).

3. **Scoring without ML**: Phase 1 uses deterministic heuristics. Phase 2 adds outcome-based ML improvements using actual platform enrollment data.

4. **Role in DB, not auth provider**: Neon Auth doesn't natively support custom roles. We store role in `user_profiles.role`. All role checks are done at the API layer and in client layouts, not in the auth provider.

5. **onConflictDoUpdate for college cache**: Using Postgres upsert ensures idempotent Scorecard imports. Safe to call multiple times.

6. **No field-of-study matching in Phase 1**: Scorecard's field-of-study data requires separate API calls per institution. Phase 2 will add major-specific earnings matching.

### Known Gaps (Phase 2)

- College data may be 1-2 years old (Scorecard lag)
- Admission probability is a proxy (acceptance rate), not a student-specific prediction
- No first-gen-specific graduation rate data surfaced in Phase 1 (data exists in Scorecard, add in Phase 2)
- No scholarship matching yet (Phase 2: Scholarship Agent)
- No FAFSA guidance yet (Phase 3: Application Management Agent)
